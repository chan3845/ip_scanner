stages:
  - lint
  - test
  - build
  - scan
  - deploy
  - post-deploy
  - cleanup



variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  DOCKER_IMAGE_NAME: "your-registry.example.com/your-namespace/ip_scanner:$CI_COMMIT_SHORT_SHA"
  REMOTE_HOST: "your.remote.docker.host"
  DEPLOY_DIR: "$HOME/ip_scanner"
  HARBOR_USER: "registry-user" # you can also set in the GitLab CI/CD > Variables
  HARBOR_PASSWORD: "registry-password" # you can also set in the GitLab CI/CD > Variables

cache:
  paths:
    - .cache/pip

before_script:
  - echo "Running job in $CI_PIPELINE_ID"

# -------------------------------------
# Lint stage (check code quality)
# -------------------------------------
lint_code:
  stage: lint
  image: python:3.12
  script:
    - pip install flake8
    - flake8 app/ --max-line-length=100 || true
  only:
    - merge_requests
    - branches
  tags:
    - r1-docker-executor

# -------------------------------------
# Unit Tests
# -------------------------------------
test_app:
  stage: test
  image: python:3.12
  before_script:
    - apt-get update && apt-get install -y --no-install-recommends gcc libc6-dev
    - pip install --upgrade pip
    - cd app
    - pip install -r requirements.txt
  script:
    - python -m pytest test_app.py -v --junitxml=app/test-report.xml
  artifacts:
    when: always
    reports:
      junit: app/test-report.xml
    paths: 
      - app/test-report.xml
    expire_in: 1 week
  tags:
    - r1-docker-executor
# -------------------------------------
# Build Docker Image
# -------------------------------------
build_image:
  stage: build
 #  Using custom Docker-in-Docker image that includes root CA cert for private registry trust
  image: your-registry.example.com/your-namespace/custom-dind-with-ca:latest
  services:
    -  name: docker:dind
       alias: docker
  variables: 
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
  script:
    - docker login your-registry.example.com -u "$HARBOR_USER" -p "$HARBOR_PASSWORD"
    - docker build -t $DOCKER_IMAGE_NAME ./app
    - docker push $DOCKER_IMAGE_NAME
  only:
    - main
    - tags
  tags:
    - r1-docker-executor

# -------------------------------------
# Scan for Vulnerabilities
# -------------------------------------
scan_image:
  stage: scan
  image: 
    name: aquasec/trivy:latest
    entrypoint: [""]
  variables:
    TRIVY_USERNAME: "$HARBOR_USER"
    TRIVY_PASSWORD: "$HARBOR_PASSWORD"
    TRIVY_INSECURE: "true"  # Skip TLS verification for private registry
    TRIVY_NON_SSL: "true"   # Allow non-SSL connections if needed
  before_script:
    - trivy --cache-dir /tmp/trivy-cache image --download-db-only  # Pre-download DB
  script:
    - trivy --cache-dir /tmp/trivy-cache image --exit-code 1 --severity HIGH,CRITICAL --ignore-unfixed $DOCKER_IMAGE_NAME
  allow_failure: true
  tags:
    - r1-docker-executor  
# -------------------------------------
# Deploy to Remote Host (via SSH)
# -------------------------------------
deploy_remote:
  stage: deploy
  image: python:3.11
  before_script:
  - 'command -v ssh-agent >/dev/null || ( apt-get update -y && apt-get install -y openssh-client )'
  - eval $(ssh-agent -s)
  - ssh-add <(echo "$SSH_PRIVATE_KEY") 
  - mkdir -p ~/.ssh
  - chmod 700 ~/.ssh
  - ssh-keyscan -t rsa,ed25519 $REMOTE_HOST >> ~/.ssh/known_hosts
  script:
    - |
      if ! ssh gitlab-runner@$REMOTE_HOST '[ -f ~/ip_scanner/cidrs.json ]'; then
        echo "cidrs.json not found on remote. Uploading...";
        ssh gitlab-runner@$REMOTE_HOST 'mkdir -p ~/ip_scanner';
        scp cidrs.json gitlab-runner@$REMOTE_HOST:~/ip_scanner/cidrs.json;
      else
        echo "cidrs.json already exists. Skipping upload.";
      fi

    - |
      ssh gitlab-runner@$REMOTE_HOST " 
        docker pull '$DOCKER_IMAGE_NAME' && 
        docker stop ip_scanner || true && 
        docker rm ip_scanner || true && 
        #    mv ~/cidrs.json ~/ip_scanner && 
        docker run -d --name ip_scanner -p 5000:5000 -v /home/gitlab-runner/ip_scanner/cidrs.json:/app/cidrs.json -v /etc/localtime:/etc/localtime:ro '$DOCKER_IMAGE_NAME'
        "
  only:
    - main
    - tags
  environment:
    name: production
  tags:
    - r1-docker-executor


# -------------------------------------
# Post-deployment (Health checks, notify)
# -------------------------------------
post_deploy:
  stage: post-deploy
  image: curlimages/curl
  script:
    - curl --fail http://$REMOTE_HOST:5000/health || exit 1
    - echo "Deployment successful!"
  when: on_success
  tags: 
    - r1-docker-executor

# -------------------------------------
# Cleanup (Optional)
# -------------------------------------
cleanup:
  stage: cleanup
  script:
    - docker image prune -af
  when: always
  tags:
    - r1-shell-executor
